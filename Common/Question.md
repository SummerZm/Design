## 以解决问题为最终目的 ##

### <b>一. 代码框架可维护/拓展问题</b> ###
1. 如何实现全局唯一？
2. 如何封装对象创建逻辑？
3. 如何正确的创建对象？
4. 如何处理创建大对象内存消耗和性能问题[原型&享元]？
5. 如何做控制访问，附加功能？
6. 如何解决复杂的继承问题,灵活的更换功能实现逻辑？
7. 如何处理接口间的不兼容？
8. 如何实现根据不同的紧急程度通过不同是通知方式发生消息[多个维度灵活组合]？
9. 如何减少网络请求[接口颗粒的控制]？
10. 如何模块与模块之间消息交互[观察&中介]？
11. 如何实现过滤拦截器功能？
12. 迭代器的目的是什么？
13. 状态流程切换的实现方式有哪些，怎么选？
14. 备忘录模式要注意的细节是什么？
15. 如何在不改变算法整体框架的情况下，重新定义算法中的某些步骤或拓展框架？
16. 如何处理冗长的if-else代码结构？ 

### <b>项目的结构</b> ###
- 业务无关的通用功能模块
    1. 类库（library）: 提供一组 API 接口 [Google Guava] 
    2. 框架（framework）: 提供骨架代码，能让业务开发人员聚焦在业务开发部分 [EventBus、DI 容器]
    3. 功能组件（component）: 提供一组具有某一特殊功能的 API 接口
        -更加聚焦和重量级，ID 生成器有可能会依赖 Redis 等外部系统。

- 与业务有关又可复用: 设计成独立的系统。

### <b>编程范式的特点</b> ###
1. 面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性
2. 面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离
3. 面向函数编程最大的特点是： 程序可以用一系列数学函数或表达式的组合来表示 [无状态]

### <b>设计模式应用相关例子</b> ###

- JDK 日历对象工厂模式和建造者模式, collection的装饰器模式,适配器模式
- 模板模式: Java Servlet、JUnit TestCase、Java InputStream、Java AbstractList 
- 享元模式: Integer 类中的 -128~127 之间的整型对象是可以复用的，String 类型中的常量字符串也可以复用
- 职责链模式: Java Servlet 中的 Filter.
- 单例模式: 每个 Java 应用在运行时会启动一个 JVM 进程，每个 JVM 进程都只对应一个 Runtime 实例，用于查看 JVM 状态以及控制 JVM 行为。
- JDK观察者模式: 
    1. 为了保证在多线程环境下，添加、移除、通知观察者三个操作之间不发生冲突?
        - Observable 类中的大部分函数都通过 synchronized 加了锁

    2. notifyObservers() 这函数就没有加 synchronized 锁。这是为什么呢？
        - 主要是出于性能的考虑。notifyObservers() 函数依次执行每个观察者的 update() 函数，每个 update() 函数执行的逻辑提前未知，有可能会很耗时。

    3. JDK 采用了一种折中的方案。这个方案有点类似于我们之前讲过的让迭代器支持”快照“的解决方案
        - 在 notifyObservers() 函数中，我们先拷贝一份观察者列表，赋值给函数的局部变量(局部变量是线程私有的，并不在线程间共享)。
        - 问题: 在创建好快照之后，添加、删除观察者都不会更新快照，新加入的观察者就不会被通知到，新删除的观察者仍然会被通知到。

- Wrapper 模式:
    1. 代理模式、装饰器、适配器模式，通过 Wrapper 类二次封装原始类。
    2. 它们的代码实现也很相似，都可以通过组合的方式，将 Wrapper 类的函数实现委托给原始类的函数来实现。
    3. 应用: 用一个类去实现接口,之后继承这个类，可以使用基类中的默认实现，不用将接口所有函数重新实现一遍。

### <b>大型项目设计/管理</b> ###

- 项目设计要求
    1. 封装与抽象
    2. 分层与模块化
    3. 基于接口通信
    4. 高内聚、松耦合
    5. 为扩展而设计
    6. KISS 首要原则
    7. 最小惊奇原则

- 项目管理要求
    1. 代码规范
    2. 单元测试
    3. Code Review
`   4. 开发未动、文档先行

### <b>Spring设计学习</b> ###
1. 约定大于配置 [使用注解]
2. 低侵入松耦合 [业务代码不入侵框架代码-AOP-通过配置]
3. 模块化轻量级等[]


### <b>二. 特定语言实现相关问题</b> ###
1. Java语言中的反射和泛型原理？

### <b>三. 实际应用场景问题</b> ###
- 如何给一个文件中的内容进行排序？
    1. 小文件：
        - 读内容分割成一个一个的数字，放到内存数组中，使用某种排序算法

    2. 大文件：[10GB~100GB - 没办法一次性加载文件中的所有数据到内存中]
        - 外部排序算法
        - 外部排序进行优化，加入多线程并发排序的功能，类似“单机版”的 MapReduce

    3. 特大文件：[100TB~]
        - MapReduce 框架，利用多机的处理能力，提高排序的效率












